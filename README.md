# go-test
1. Выберите некорректное объявление:
* `var c, python, java = true, false, "no!"`
* `var x := 23`
* `t := false`
* `var x int`

2. Нулевое значение для типа "map":
* `0`
* `nil`
* `interface{}`

3. Имена, экспортируемые из модуля:
* начинаются с `_`
* объявляются с ключевым словом `export`
* начинаются с заглавной буквы

4. Найдите некорректное объявление:
* `func add(x int, y int) int`
* `func swap(x, y string) (string, string)`
* `func split(sum int) (x, y int)`
* `func div(x int, y int) int, float`

5. функция recover():
* необходимая для реализации интерфейса Error
* используется в "отложенных" функциях для обработки паники
* используется для выхода из блока try ... except

6. Что выведет на экран следующая программа?
```
primes := [6]int{2, 3, 5, 7, 11, 13}
var s []int = primes[1:4]
fmt.Println(len(s), cap(s))
```
* 4 5
* 3 5
* 3 6
* 4 6

7. горутина (goroutine) - это
* базовый интерфейс
* легковесный тред
* другое название для POSIX thread-ов
* замыкание функции

8. Программисты на Go очень хотят видеть в языке
* множественное наследование
* дженерик
* динамическую типизацию

9. Может ли Go автоматически определять тип переменных
* Нет, Go статически типизирован, поэтому тип нужно всегда указывать явно
* Да, в Go есть система вывода типов Хиндли-Милнера, поэтому типы указывать вообще не нужно
* Да, для этого есть ключевое слово `auto`
* Да, для этого есть специальный оператор `:=`

10. С помощь какого типа данных в Go представляются строки ?
* `[]char`
* `\*byte`
* `string`
* `String`

11. Каким значением инициализируется переменная `res` в коде
```
func Concat(parts ...string) string {
    var res string  // вот
}
```
* `nil`
* `""`
* компилятор сообщит об ошибке
* поведение не определено, компилятор покажет предупреждение

12. Возможно ли стравнивать между собой (`==`) переменные типов `float32` и `int32`
* Да, Go преобразует тип и сравнит значения
* Да, Go автоматически округлит значение с плавающей точкой
* Нет, переменные разных типов нельзя сравнивать

13. Как в Go выглядит преобразование типа `int32` в `int64`
* `a := (int64)b`
* `a := cast(b to int64)
* `a := int64(b)`
* `a := b.(int64)`

14. Константы в Go объявляются
* С помощью ключевого слова `const`, например `const x = 3`
* C помощью модификатора `const`, например `const var x = 3`
* С помощью модификатора `final`, наприме `final var x = 3`
* C помощью макроса `#define`, например `#define x 3`

15. Для создания сложных типов данных (содержащих значения разных элементарных типов) в Go используется
* Структуры, ключевое слово `struct`
* Классыы, ключевое слово `class`
* Интерфейсы, ключевое слово `interface`
* Перечисления, ключевое слово `enum`

16. Какое из указанных слов НЕ является ключевым в Go
* `while`
* `import`
* `go`
* `package`

17. CGO это
* Механизм вызова функций на языке C из Go кода
* Компилятор из языка Go в С
* Препроцессор, позволяющий использовать макросы в Go

18. Каналы в языке Go это
* Тип для чтения и записи данных в файл
* Тип данных для синхронизации и передачи данных между горутинами
* Библиотека для работы с TCP протоколом

19. В чем отличие буферизованных и небуферизованных каналов ?
* Буферизованные каналы обладают большей производительностью
* Запись в буферизованный канал никогда не блокирует горутину
* Запись в буферизованный канал не блокирует горутину, если есть место в буфере

20. Есть ли в языке Go мьютексы (mutex) ?
* Есть, но это внутренний механизм, он не доступен в стандартной библиотеке
* Есть, тип sync.Mutex
* Нет, вместо них в Go используются каналы

21. Для чего используется контекст (context) в Go ?
* Для расширения синтаксиса языка
* Для ограничения времени (или отмены) выполнения горутин
* Для создания совместного доступа к глобальным переменным из разных горутин

22. Как определяется что тип данных реализует некоторый интерфейс в Go ?
* С помощью ключевого слова implements
* С помощью ключевого слова extends
* Автоматически, если в типе реализованы все нужные методы

23. Что дает рефлексия (reflect) в Go ?
* Возможность определить тип данных скрывающийся за интерфейсом
* Возможность создавать функции, которые вызывают сами себя
* Возможность создавать типы данных, ссылающиеся на себя, например связанные списки.

24. В процессе получения данных (по протоколу TCP) с удаленного сервера у него пропало питание. Как обработать это в языке Go ?
* Метод Read немедленно вернет сетевую ошибку, нужно ее обработать
* Метод Read немедленно вернет ошибку EOF, нужно ее обработать
* Необходимо заранее установить таймаут на получение данных и обработать ошибку по его наступлению

25. При развертывании Web приложения на Go вам необходимо установить на сервер
* Копилятор Go и исходный код вашего приложения
* Виртуальную машину Go (runtime) и скомпилированный код вашего приложения
* Скомпилированный код вашего приложения, больше ничего не нужно

26. Что такое Service Discovery ?
* Механизм обнаружения endpoint-ов (ip:port) ваших сервисов при развертывании в облаке
* Механизм публикаци спецификации API ваших приложений
* Публикация вашего сервиса в каком-либо магазине, например AppStore

27. Что такое слайс в Go
* Динамический массив, в памяти представлен как структура
```go
type slice struct {
    len int
    cap int
    pointer *type
}
```
* Массив, в памяти представлен как
```go
type slice [x]type
```
* Динамический массив, в памяти представлен как структура
```go
type slice struct {
    len int
    cap int
    pointer *[]type
}
```

28. Как наболее оптимизированно реализовать структуру данных `множество` в Go, где типом элемента является строка
* В виде массива
* В виде слайса
* В виде карты где ключем будет строка а значением число (точность может быть любая)
* В виде карты где ключем будет строка а значением булевый тип
* В виде карты где ключем будет строка а значением будет пустая структура

29.Произойдет ли утечка горутины в данном участке кода (в ответе надо обьяснить выбранный ответ)
```go
func main() {
     ch := make(chan int)

     go func() {
         val := <-ch
         fmt.Println("We received a value:", val)
     }()
}
```
* Да
* Нет

30.Что выведет код
```go
func main() {
	i := 0
	defer fmt.Println(i)
	i++
	return
}
```
* 1
* 0

31.Что выведет код
```go
func main() {
	for i := 0; i < 5; i++ {
		defer func(i int) {
			fmt.Printf("%v ", i)
		}(i)
	}

}
```

* 4 3 2 1 0
* 5 5 5 5 5
* 0 1 2 3 4
* 5 4 3 2 1
* 1 2 3 4 5

32.Что выведет код
```go
func main() {
	for i := 0; i < 5; i++ {
		defer func(i *int) {
			fmt.Printf("%v ", *i)
		}(&i)
	}

}
```

* 4 3 2 1 0
* 5 5 5 5 5
* 0 1 2 3 4
* 5 4 3 2 1
* 1 2 3 4 5

33.Что выведет код
```go
func main() {
	test1 := []int{1, 2, 3, 4, 5}
	test1 = test1[:3]
	test2 := test1[3:]
	fmt.Println(test2[:2])
}
```

* `[4, 5]`
* `[2, 3]`
* `panic`
